---
title: AltspaceVR Mobile 效能指南
description: 瞭解如何使用各種 Unity 屬性，讓您的世界在 Oculus 的行動裝置上發揮效能
ms.date: 04/20/2021
ms.topic: article
keywords: 世界編輯器、效能、oculus、請求、unity、材質、lightmaps、stats、profiler、繪製呼叫、altspacevr、上載者
ms.openlocfilehash: d9bb02cf6c51a604b858caf36ebbc5548e4fe267
ms.sourcegitcommit: ab0ca34d20bbbcee3ce3415b17a681f8678565b7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/12/2021
ms.locfileid: "113634289"
---
# <a name="altspacevr-mobile-performance-guide"></a><span data-ttu-id="30d63-104">AltspaceVR Mobile 效能指南</span><span class="sxs-lookup"><span data-stu-id="30d63-104">AltspaceVR Mobile Performance Guide</span></span>

## <a name="main-points"></a><span data-ttu-id="30d63-105">**重點：**</span><span class="sxs-lookup"><span data-stu-id="30d63-105">**Main Points:**</span></span>

* <span data-ttu-id="30d63-106">**72 FPS** 在 Oculus 時的操作1和2，是目標。</span><span class="sxs-lookup"><span data-stu-id="30d63-106">**72 FPS** on Oculus Quest 1 and 2, is the target.</span></span>
* <span data-ttu-id="30d63-107">透過 **靜態批次處理來減少繪製呼叫** 是不可或缺的，目標是 **少於 25 drawcalls**</span><span class="sxs-lookup"><span data-stu-id="30d63-107">**Reducing Draw Calls via Static Batching** is essential, aim for **less than 25 drawcalls**</span></span>
* <span data-ttu-id="30d63-108">**每個物件都有一個** 資料，可鼓勵靜態批次處理 (將多材質物件分割成不同的物件) 。</span><span class="sxs-lookup"><span data-stu-id="30d63-108">**One material per object** to encourage Static Batching (split up multi-material objects into separate objects).</span></span>
* <span data-ttu-id="30d63-109">在大多數情況下，環境中的 **物件** 都應該設定為「**靜態**」。</span><span class="sxs-lookup"><span data-stu-id="30d63-109">**Objects** in an environment should be set to **‘Static’** in most cases.</span></span>
* <span data-ttu-id="30d63-110">**每個場景一個 lightmap**，一個2k 或一個4k 用於整個場景，每個單位 ~ 25 個材質，每個物件的 lightmap 調整規模應調整， (調整圖表) </span><span class="sxs-lookup"><span data-stu-id="30d63-110">**One lightmap per scene**, one 2k or one 4k for the whole scene, ~25 texels per unit, lightmap scaling should be tuned per object (scaling chart below)</span></span>
* <span data-ttu-id="30d63-111">**使用行動品質著色** 器 (也就是「行動/擴散」等 ) ，請避免使用 Unity 標準著色器/.Pbr/反映探查/輕量探查，因為它們是大量作業，而探查的情況下會新增繪製呼叫。</span><span class="sxs-lookup"><span data-stu-id="30d63-111">**Use Mobile-quality shaders** (that is, ‘Mobile/Diffuse’, etc.), avoid the Unity Standard shader/PBR/Reflection Probes/Light Probes as they are heavy operations and in the case of the probes will add draw calls.</span></span>
* <span data-ttu-id="30d63-112">螢幕上 **小於10萬個三角形**</span><span class="sxs-lookup"><span data-stu-id="30d63-112">**Less than 100k triangles** on-screen</span></span>
* <span data-ttu-id="30d63-113">**遮蔽的剔除** 有助於減少螢幕上的多邊形，雖然有預付成本可讓遮蔽剔除啟用，因此請使用 [診斷] 面板來測量 Altspace 中的畫面播放速率效果。</span><span class="sxs-lookup"><span data-stu-id="30d63-113">**Occlusion Culling** can help reduce on-screen polygons, although there is an up-front cost to having occlusion culling enabled so measure the effect on framerate in Altspace using the Diagnostics Panel.</span></span>
* <span data-ttu-id="30d63-114">針對場景中的所有 **材質** ，請使用 [ **Android 的覆寫** ]，並將其設定為 **RGB () 壓縮的 ASTC 6x6 組塊格式**。</span><span class="sxs-lookup"><span data-stu-id="30d63-114">For all **textures** in a scene, use **‘Override for Android’** and set them to **RGB(A) Compressed ASTC 6x6 block format**.</span></span>  <span data-ttu-id="30d63-115">將您的 Android 組建設定壓縮為預設 (在： File/Build 設定/Android/Texture 壓縮： ' 不覆寫 ' ) ，讓 Lightmaps 不會取得 ASTC 壓縮。</span><span class="sxs-lookup"><span data-stu-id="30d63-115">Leave your Android Build Settings compression to default (found in: File/Build Settings/Android/Texture Compression: ‘Don’t override’), so that Lightmaps don’t get ASTC compression.</span></span>  <span data-ttu-id="30d63-116">藉由執行上述工作，並透過在物件之間共用資料，我們會嘗試將場景的 unity 套件保持在 **Android 的 10-20 MB** 左右。</span><span class="sxs-lookup"><span data-stu-id="30d63-116">By doing the above, and by sharing materials across objects, we try to keep our scene’s unity package to around **10-20 MB for Android**.</span></span>

<span data-ttu-id="30d63-117">一般的目標是在裝置之間達到可接受的畫面播放速率–在 Oculus 的結果1和2中，當場景填入時，場景將會從所有有利點的 72 FPS 執行（雖然 60-72 FPS 的範圍通常是更實際的目標）。</span><span class="sxs-lookup"><span data-stu-id="30d63-117">The general goal is to hit an acceptable framerate across devices – on Oculus Quest 1 and 2 ideally the scene will run at 72 FPS from all vantage points when the scene is populated, although a range of 60-72 FPS is often a more realistic target.</span></span>

<span data-ttu-id="30d63-118">您所使用 (在 AltspaceVR 應用程式中找到的任何裝置上的畫面播放速率可透過 **設定/Support/Show 診斷面板/FPS**) 來測量。</span><span class="sxs-lookup"><span data-stu-id="30d63-118">Framerate can be measured within AltspaceVR on whichever device that you’re using (found in the AltspaceVR app under **Settings/Support/Show Diagnostics Panel/FPS**).</span></span>

<span data-ttu-id="30d63-119">提供可用來協助您更妥善優化幕後的標準 Unity 工具：</span><span class="sxs-lookup"><span data-stu-id="30d63-119">A rundown of the standard Unity tools available to help you to better-optimize your scenes:</span></span>

## <a name="stats-panelframe-debuggerprofiler"></a><span data-ttu-id="30d63-120">**統計資料面板/框架偵錯工具/Profiler**</span><span class="sxs-lookup"><span data-stu-id="30d63-120">**Stats Panel/Frame Debugger/Profiler**</span></span>

* <span data-ttu-id="30d63-121">這些工具將是您改善場景效能的最佳朋友。</span><span class="sxs-lookup"><span data-stu-id="30d63-121">These tools will be your best friends in improving your scene's performance.</span></span>  <span data-ttu-id="30d63-122">只有在 **場景正在編輯器中播放** 時，才可以參考它們，因為它們的值會與場景未播放時的值不同 (也就是在場景未播放時，不會發生自動靜態批次處理) </span><span class="sxs-lookup"><span data-stu-id="30d63-122">They can **only be referenced while the scene is Playing in-editor**, as their values will be different from when the scene is not playing (that is, Automatic static batching won't be happening when the scene isn't playing)</span></span>

* <span data-ttu-id="30d63-123">**統計資料面板** (可在 [統計資料] 下的 [遊戲] 視圖中查看 ) 將會顯示 **已儲存的批次/批次數量、SetPass 呼叫和畫面播放速率**。</span><span class="sxs-lookup"><span data-stu-id="30d63-123">**Stats Panel** (viewable in Game View under 'Stats') will show you the amount of **Batches/Batches Saved, SetPass Calls, and Framerate**.</span></span>

    * <span data-ttu-id="30d63-124">批次–目前相機的觀點可以看到的目前繪製呼叫數量。</span><span class="sxs-lookup"><span data-stu-id="30d63-124">Batches – the amount of current draw calls that are visible from the current camera's perspective.</span></span>  <span data-ttu-id="30d63-125">針對環境，**少於25個批次** 是適合的目標。</span><span class="sxs-lookup"><span data-stu-id="30d63-125">**Fewer than 25 batches** for an environment is a good target to aim for.</span></span>
    * <span data-ttu-id="30d63-126">批次已儲存 (只有在場景播放時才看得見) –透過 **靜態批次處理或 GPU 實例** 減少的數量繪製呼叫</span><span class="sxs-lookup"><span data-stu-id="30d63-126">Batches Saved (only visible when the scene is Playing)  – the amount draw calls that have been reduced via **Static Batching or GPU Instancing**</span></span>
    * <span data-ttu-id="30d63-127">SetPass 呼叫–場景中不同可見材質的數目</span><span class="sxs-lookup"><span data-stu-id="30d63-127">SetPass Calls – the number of different visible materials in a scene</span></span>
    * <span data-ttu-id="30d63-128">畫面播放速率–遊戲視圖中每秒的畫面格數量 (可讓您大致瞭解發生的情況;幕後應該一律在應用程式內，使用 Oculus 幀的面板來測試，因為 fps 讀出永遠與編輯器中的內容不同) </span><span class="sxs-lookup"><span data-stu-id="30d63-128">Framerate – the amount of frames-per-second in the Game view (gives you an approximate idea of what's happening; scenes should always be tested in-app, in-headset, using the Oculus Framerate panel as the fps readout will always be different than what's in-editor)</span></span>

* <span data-ttu-id="30d63-129">在 [視窗/分析]/[框架偵錯工具]) 下找到 **框架偵錯工具** (。</span><span class="sxs-lookup"><span data-stu-id="30d63-129">**Frame Debugger** (found under Window/Analysis/Frame Debugger).</span></span>  <span data-ttu-id="30d63-130">啟用時，類固醇上的 [統計資料] 面板可讓您查看 GPU 繪製的內容，以建立最終映射，顯示從 first 到 last 的 drawcalls 清單。</span><span class="sxs-lookup"><span data-stu-id="30d63-130">The Stats Panel on steroids that, when enabled, will allow you to see what the GPU is drawing to create the final image, showing you a list of drawcalls from first to last.</span></span>  <span data-ttu-id="30d63-131">這會讓您瞭解為什麼繪製呼叫未以先前的繪製呼叫進行批次處理 (也就是「此物件使用不同的材質」或「這個物件使用不同的 Lightmap」 ) ，而且是一個絕佳的方式，可讓您瞭解您場景中的這兩種情況，以及如何以及為何某些視覺效果選擇可能會耗費大量計算資源。</span><span class="sxs-lookup"><span data-stu-id="30d63-131">It will give you reasons for why a draw call wasn't batched with a previous draw call (that is, 'This object uses a different Material' or 'This object uses a different Lightmap'), and is an excellent way towards developing an understanding both of what's happening in your scene, and how and why certain visual choices can be computationally expensive.</span></span>

* <span data-ttu-id="30d63-132">**Profiler** 會顯示當遊戲執行時，在任何時間點使用的電腦部分。</span><span class="sxs-lookup"><span data-stu-id="30d63-132">**Profiler** will show you what parts of the computer are being used at any point in time while the game is running.</span></span> <span data-ttu-id="30d63-133">有助於判斷 bottlenecking 效能。</span><span class="sxs-lookup"><span data-stu-id="30d63-133">Helpful in determining where performance is bottlenecking.</span></span>  <span data-ttu-id="30d63-134">比方說，如果您在場景中看到大量的 CPU 使用率，這可能是因為有太多繪製呼叫，或如果您看到大量的 GPU 使用量， (也可能會發生太多的過度繪製，也就是轉譯單一圖元以產生最終影像) 的次數，可能是因為有多個透明的表面，或在超出視野時未挑選的物件。</span><span class="sxs-lookup"><span data-stu-id="30d63-134">For instance, if you are seeing heavy CPU usage in your scene, it could be that there are too many draw calls, or if you're seeing heavy GPU usage, there might be too much overdraw happening (that is, the number of times that a single pixel is rendered to produce the final image) which can be caused by having multiple transparent surfaces, or objects not being culled when out of view.</span></span>

## <a name="draw-calls-shadersmaterialsobjects"></a><span data-ttu-id="30d63-135">**繪製呼叫 (著色器/材質/物件)**</span><span class="sxs-lookup"><span data-stu-id="30d63-135">**Draw Calls (Shaders/Materials/Objects)**</span></span>

* <span data-ttu-id="30d63-136">每次需要轉譯著色器、材質或物件時，CPU 都必須指示交換器的 GPU (也稱為「繪製呼叫」，堆疊 **' drawcalls '**) 。</span><span class="sxs-lookup"><span data-stu-id="30d63-136">Every time that a shader, material or object needs to be rendered, the CPU has to instruct the GPU of the switch (also known as 'draw calls', colloquially **'drawcalls'**).</span></span>  <span data-ttu-id="30d63-137">也就是說，如果您有5個著色器、10個材質和20個物件，則以最大者為准;您大約需要 20 drawcalls。</span><span class="sxs-lookup"><span data-stu-id="30d63-137">That is, if you have 5 shaders, 10 materials, and 20 objects, with whichever is greatest; you'll have approximately 20 drawcalls.</span></span>  <span data-ttu-id="30d63-138">其他可乘以 drawcalls 的專案，包括在不同的 lightmaps 上具有物件，或在場景中有一個以上的即時光線 (也就是說，一個點光線會將另一個 drawcall 新增至其) 範圍內的每個物件，因此通常應該避免場景的方向光線以外的任何專案。</span><span class="sxs-lookup"><span data-stu-id="30d63-138">Other things that can multiply drawcalls include having objects on different lightmaps or having more than one real-time light in a scene (that is, one point light will add another drawcall to every object that is within its range), so generally anything other than a scene's directional light should be avoided.</span></span>  <span data-ttu-id="30d63-139">反映探查和淺色探查也會將繪製呼叫乘以它們所叫用的任何物件，因此應該避免它們。</span><span class="sxs-lookup"><span data-stu-id="30d63-139">Reflection probes and light probes will also multiply draw calls on whichever objects that they hit, so they should be avoided.</span></span>

* <span data-ttu-id="30d63-140">**靜態批次處理** 會在傳送至 GPU (時，將類似材質的物件批次處理成單一物件，) 並將上述範例中的所有物件都設定為 [靜態]，藉此將上述範例中的所有物件都設定為 [靜態]，就可以將場景縮減為大約 10 drawcalls，1代表每個材質。</span><span class="sxs-lookup"><span data-stu-id="30d63-140">**Static Batching** will batch objects that share like-materials into a single object when sent to the GPU (with Occlusion Culling discarding meshes that are out of view), so by setting all objects in the above example to 'Static', you would reduce the scene to approximately 10 drawcalls, 1 for every material.</span></span> 

* <span data-ttu-id="30d63-141">當物件具有與另一個物件完全相同的材質時，就會發生資料 **批次**; 不過，如果物件有多個資料，則不會使用具有較少材質的物件進行批次處理。</span><span class="sxs-lookup"><span data-stu-id="30d63-141">**Material batches** occur when an object has the exact materials as another object, however if an object has multiple materials, it won't batch with an object that has fewer materials.</span></span>  <span data-ttu-id="30d63-142">基於這個理由： **物件必須只有1個** 資料，而使用數個材質的物件應該分割成每個材質的個別物件。</span><span class="sxs-lookup"><span data-stu-id="30d63-142">For this reason: **Objects MUST only have 1 material**, and objects that use several materials should be split into separate objects per material.</span></span>  <span data-ttu-id="30d63-143">您可以透過 **材質 Atlasing** 來縮減 **材質批次** (結合多個唯一物件的材質來共用單一材質表，讓它們全都使用相同的材質) 。</span><span class="sxs-lookup"><span data-stu-id="30d63-143">**Material batches** can be reduced through **Texture Atlasing** (combining multiple unique object's textures to share a single texture sheet so that they all use the same material).</span></span>  <span data-ttu-id="30d63-144">如果可能的話，請儘量將圖集數量維持在單一2k 或4k 材質/材質之間。</span><span class="sxs-lookup"><span data-stu-id="30d63-144">Try to keep the amount of Atlases down to a single 2k or 4k texture/material per scene if possible.</span></span>

## <a name="scene-complexity"></a><span data-ttu-id="30d63-145">**場景複雜性**</span><span class="sxs-lookup"><span data-stu-id="30d63-145">**Scene Complexity**</span></span>

* <span data-ttu-id="30d63-146">**幾何** -嘗試為10萬以下的環境保持螢幕三角形。</span><span class="sxs-lookup"><span data-stu-id="30d63-146">**Geometry** – try to keep onscreen triangles for environments below 100k.</span></span>  <span data-ttu-id="30d63-147">使用 Unity 遊戲面板中的 [統計資料] 索引標籤，以查看您在場景中的各種有利點所達到的三角形計數。</span><span class="sxs-lookup"><span data-stu-id="30d63-147">Use the ‘Stats’ tab in Unity’s Game panel to see what triangle counts you’re hitting from various vantage points in the scene.</span></span>  <span data-ttu-id="30d63-148">這種情況的 .props 應該是在三角形範圍的 ' 數百 ' 中，而且只有在數以千計的三角形範圍中 .props 重要的「主圖」。</span><span class="sxs-lookup"><span data-stu-id="30d63-148">Props as such should be in the ‘hundreds’ of triangles range, with only important ‘hero’ props in the thousands of triangles range.</span></span> 

* <span data-ttu-id="30d63-149">在技術上，您可以使用 **LODs** (層級的詳細資料網格) ，雖然 Unity 的預設 lightmap 解決方案並不會在 LODs 之間共用 lightmap 資料，因此您可以在此解決方案的 lightmapping 切換時取得 LODs 構件。</span><span class="sxs-lookup"><span data-stu-id="30d63-149">You can technically use **LODs** (level of detail meshes), although Unity’s default lightmap solution does not share lightmap data between LODs, so you may get lightmapping artifacts when the LODs switch at this resolution.</span></span>  <span data-ttu-id="30d63-150">或者，您也可以使用」 LOD 群組元件來進行簡單的距離剔除，即使物件沒有較低的」 LOD 網格也一樣：</span><span class="sxs-lookup"><span data-stu-id="30d63-150">Alternatively, you can use the LOD Group component for simple Distance Culling, even if the object doesn’t have lower LOD meshes:</span></span>

![Unity 中的」 LOD 群組視窗](images/world-building-lod-Group.png)

* <span data-ttu-id="30d63-152">**遮蔽的剔除** 會減少轉譯成隻有相機視圖中的物件，而且會立即看見 (也就是說，從 view pixels occluded 的物件是挑選) 。</span><span class="sxs-lookup"><span data-stu-id="30d63-152">**Occlusion Culling** reduces the number of objects that are rendered to only what is within the camera's view frustum, and that are immediately visible (that is, objects that are Occluded from view are Culled).</span></span>  <span data-ttu-id="30d63-153">遮蔽的剔除應該幾乎一律針對您的場景進行內建，而層級應設計來支援它 (也就是，如果您有較大的層級，您可以使用牆或大型物件來分割播放程式的程式碼，如此一來，他們就不能一直看到到層級的相對端點。</span><span class="sxs-lookup"><span data-stu-id="30d63-153">Occlusion culling should almost always be baked for your scene, and levels should be designed to support it (that is, if you have a large level, walls or large objects can be used to break up the player's line-of-sight, so that they can't always see through to the opposite end of the level.</span></span>  <span data-ttu-id="30d63-154">預設的製作設定應該可以運作，不過您可能必須壓縮「最小 Occluder」或「最小洞」值。</span><span class="sxs-lookup"><span data-stu-id="30d63-154">The default bake settings should work, although you may have to shrink the 'Smallest Occluder' or 'Smallest Hole' values.</span></span>  <span data-ttu-id="30d63-155">針對您可以在物件或透明物件中看到的物件等物件，您應該在 [靜態] 下拉式功能表中關閉物件的「Occluder」狀態，使其背後的物件不會錯誤地 pixels occluded。</span><span class="sxs-lookup"><span data-stu-id="30d63-155">For objects like fences where you may be able to see through cracks in the object, or transparent objects, you should turn off the object's 'Occluder' status in the 'Static' drop-down menu so that objects behind it aren't erroneously occluded.</span></span> 

## <a name="lightmaps"></a><span data-ttu-id="30d63-156">**Lightmaps**</span><span class="sxs-lookup"><span data-stu-id="30d63-156">**Lightmaps**</span></span>

* <span data-ttu-id="30d63-157">在理想情況下， **每個場景只會有一個 lightmap** (一個2k 或一個4k 用於所有) 的專案;較低的解析度 lightmaps 比許多較低的解析度 lightmaps 更好。</span><span class="sxs-lookup"><span data-stu-id="30d63-157">Ideally just **one lightmap per scene** (one 2k or one 4k for everything), if not; fewer lightmaps of higher resolutions are better than many lightmaps of lower resolutions.</span></span>
* <span data-ttu-id="30d63-158">擁有多個 lightmaps 也會影響繪製呼叫的數目，因為有或沒有 lightmaps 的物件會在不同的批次，而其他 lightmaps 也會在不同的批次上。</span><span class="sxs-lookup"><span data-stu-id="30d63-158">Having multiple lightmaps can also affect the number of draw calls, as objects that either have or don't have lightmaps will be on different batches, and other lightmaps will also be on different batches.</span></span>
* <span data-ttu-id="30d63-159">一般來說， **每個單位大約25個材質** 的 Lightmap 解析度應已足夠 (設定 [光源/場景設定]) 中的解析度。</span><span class="sxs-lookup"><span data-stu-id="30d63-159">Generally, a Lightmap Resolution of around **25 texels per unit** should suffice (set resolution in the Lighting/Scene settings).</span></span>  <span data-ttu-id="30d63-160">如果您的 lightmap 有額外的空間，您可以增加這個值。</span><span class="sxs-lookup"><span data-stu-id="30d63-160">If you have extra room in your lightmap, you can increase this value.</span></span>
* <span data-ttu-id="30d63-161">變更每個物件的 **Lightmap 調整** 設定，以便為需要的物件儲存解析度。</span><span class="sxs-lookup"><span data-stu-id="30d63-161">Change the **Lightmap Scaling** setting per object so that the resolution is saved for objects that need it.</span></span> 

* <span data-ttu-id="30d63-162">**Lightmap 調整圖表** (thumb) 的規則</span><span class="sxs-lookup"><span data-stu-id="30d63-162">**Lightmap Scaling Chart** (rule of thumb)</span></span> 
    * <span data-ttu-id="30d63-163">**前景** (可周遊層級地理) ：1</span><span class="sxs-lookup"><span data-stu-id="30d63-163">**Foreground** (Traversable level geo): 1</span></span> 
    * <span data-ttu-id="30d63-164">**.Props** (特別是 .props 小於人類) ： **2-3** (以避免物件上的 lightmap 成品和接縫) </span><span class="sxs-lookup"><span data-stu-id="30d63-164">**Props** (especially props smaller than a human): **2-3** (to avoid lightmap artifacts and seams on your objects)</span></span> 
    * <span data-ttu-id="30d63-165">**Midground** 位於可周遊區域和/或大型物件（例如大樓) ： **0.5** ）之外的 (幾何</span><span class="sxs-lookup"><span data-stu-id="30d63-165">**Midground** (Geometry that is just outside of the traversable area and/or large objects like buildings): **0.5**</span></span>
    * <span data-ttu-id="30d63-166">**背景** (Vista/遙遠的物件) ： **0.02**</span><span class="sxs-lookup"><span data-stu-id="30d63-166">**Background** (Vista/distant objects): **0.02**</span></span> 
    * <span data-ttu-id="30d63-167">**透明表面** (例如玻璃) ： **0** (已停用 ' Cast/Receive Shadows ') </span><span class="sxs-lookup"><span data-stu-id="30d63-167">**Transparent Surfaces** (like glass): **0** (with 'Cast/Receive Shadows’ disabled)</span></span> 

<span data-ttu-id="30d63-168">此外，作為基準，以下是用於螢幕畫面門效果環境的一些設定：</span><span class="sxs-lookup"><span data-stu-id="30d63-168">Also, as a baseline, here are some settings that were used for the Screen Door Effect environment:</span></span>

![Unity 中的光源視窗](images/world-building-lightmaps.png)

<span data-ttu-id="30d63-170">注意：如果您使用這些設定，您可以將 Lightmapper 設定為 [GPU Lightmapper]，並將 Lightmap 大小設定為 ' 2048 '，以提供更快速的預覽 bake，然後針對最終的製作備份到 CPU 和4k。</span><span class="sxs-lookup"><span data-stu-id="30d63-170">Note: If you are using these settings, you can set the Lightmapper to 'GPU Lightmapper' and set the Lightmap Size to '2048' for much faster preview bakes, and then back up to CPU and 4k for your final bake.</span></span>

## <a name="texture-compressionfile-size"></a><span data-ttu-id="30d63-171">**紋理壓縮/檔案大小**</span><span class="sxs-lookup"><span data-stu-id="30d63-171">**Texture Compression/File Size**</span></span>

* <span data-ttu-id="30d63-172">針對我們的 Android 組建，我們會嘗試將 Unity 套件場景大小保持在大約 10-20 MB 的總。</span><span class="sxs-lookup"><span data-stu-id="30d63-172">For our Android build, we try to keep our Unity package scene size down to around 10-20 MB total.</span></span>  <span data-ttu-id="30d63-173">作法是透過在許多物件之間共用一般材質、使用頂點色彩來為物件加上色調，也可以設定 Android 的手動覆寫，讓紋理使用 **ASTC 6x6 block 壓縮**，這會比預設壓縮小。</span><span class="sxs-lookup"><span data-stu-id="30d63-173">We do this by sharing generic materials across many objects, using vertex color to tint the objects, and also by setting manual overrides for Android so that textures use **ASTC 6x6 block compression**, which will be smaller than the default compression.</span></span>

* <span data-ttu-id="30d63-174">我們未將 Android 組建設定設為 [使用 ASTC] 的原因是因為 lightmaps 不適合該壓縮 (許多 blocky 成品) ，而且我們必須在每個製作之後設定 lightmap 以使用等，如此一來，就可以更輕鬆地設定所有場景紋理的覆寫，而不是在每個 lightmap 之後更新製作的壓縮設定。</span><span class="sxs-lookup"><span data-stu-id="30d63-174">The reason that we don't set the Android build settings to use ASTC is because lightmaps do not look good with that compression (lots of blocky artifacts), and we’d have to set the lightmap to use ETC after every bake, so it is easier instead to set up the override for all scene textures once than it is to update the lightmap’s compression settings after every bake.</span></span>

![Unity 中的材質視窗](images/world-building-texutres.png)

* <span data-ttu-id="30d63-176">此外，將材質設定為使用具有2個非等層級的三線性篩選模式，可協助它們在 glancing 角度保持銳利。</span><span class="sxs-lookup"><span data-stu-id="30d63-176">Also, setting Textures to use Trilinear Filter Mode with a 2 Anisotropic Level can help them remain sharp at glancing angles.</span></span>

<span data-ttu-id="30d63-177">您可以在「 [改善世界效能」檔](improving-performance.md)中找到更多的效能秘訣和訣竅。</span><span class="sxs-lookup"><span data-stu-id="30d63-177">More performance tips and tricks can be found in the [Improving world performance documentation](improving-performance.md).</span></span>
