---
title: AltspaceVR Mobile 效能指南
description: 瞭解如何使用各種 Unity 屬性，讓您的世界在 Oculus 的行動裝置上發揮效能
ms.date: 04/20/2021
ms.topic: article
keywords: 世界編輯器、效能、oculus、請求、unity、材質、lightmaps、stats、profiler、繪製呼叫、altspacevr、上載者
ms.openlocfilehash: 9d6afba6fff85adfaa2ba290916f25c84c5377cd
ms.sourcegitcommit: 2db596ab5a1ecd4901a8c893741cc4d06f6aecea
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/25/2021
ms.locfileid: "112961207"
---
# <a name="altspacevr-mobile-performance-guide"></a>AltspaceVR Mobile 效能指南

## <a name="main-points"></a>**重點：**

* **72 FPS** 在 Oculus 時的操作1和2，是目標。
* 透過 **靜態批次處理來減少繪製呼叫** 是不可或缺的，目標是 **少於 25 drawcalls**
* **每個物件都有一個** 資料，可鼓勵靜態批次處理 (將多材質物件分割成不同的物件) 。
* 在大多數情況下，環境中的 **物件** 都應該設定為「**靜態**」。
* **每個場景一個 lightmap**，一個2k 或一個4k 用於整個場景，每個單位 ~ 25 個材質，每個物件的 lightmap 調整規模應調整， (調整圖表) 
* **使用行動品質著色** 器 (也就是「行動/擴散」等 ) ，請避免使用 Unity 標準著色器/.Pbr/反映探查/輕量探查，因為它們是大量作業，而探查的情況下會新增繪製呼叫。
* 螢幕上 **小於10萬個三角形**
* **遮蔽的剔除** 有助於減少螢幕上的多邊形，雖然有預付成本可讓遮蔽剔除啟用，因此請使用 [診斷] 面板來測量 Altspace 中的畫面播放速率效果。
* 針對場景中的所有 **材質** ，請使用 [ **Android 的覆寫** ]，並將其設定為 **RGB () 壓縮的 ASTC 6x6 組塊格式**。  將您的 Android 組建設定壓縮保留為預設 (在：檔案/組建設定/Android/材質壓縮： ' 不覆寫 ' ) ，因此 Lightmaps 不會取得 ASTC 壓縮。  藉由執行上述工作，並透過在物件之間共用資料，我們會嘗試將場景的 unity 套件保持在 **Android 的 10-20 MB** 左右。

一般的目標是在裝置之間達到可接受的畫面播放速率–在 Oculus 的結果1和2中，當場景填入時，場景將會從所有有利點的 72 FPS 執行（雖然 60-72 FPS 的範圍通常是更實際的目標）。

您可以在 AltspaceVR 中測量您所使用的裝置， (在 AltspaceVR 應用程式的 [ **設定/支援/顯示診斷面板/FPS** ]) 中找到的任何裝置。

提供可用來協助您更妥善優化幕後的標準 Unity 工具：

## <a name="stats-panelframe-debuggerprofiler"></a>**統計資料面板/框架偵錯工具/Profiler**

* 這些工具將是您改善場景效能的最佳朋友。  只有在 **場景正在編輯器中播放** 時，才可以參考它們，因為它們的值會與場景未播放時的值不同 (也就是在場景未播放時，不會發生自動靜態批次處理) 

* **統計資料面板** (可在 [統計資料] 下的 [遊戲] 視圖中查看 ) 將會顯示 **已儲存的批次/批次數量、SetPass 呼叫和畫面播放速率**。

    * 批次–目前相機的觀點可以看到的目前繪製呼叫數量。  針對環境，**少於25個批次** 是適合的目標。
    * 批次已儲存 (只有在場景播放時才看得見) –透過 **靜態批次處理或 GPU 實例** 減少的數量繪製呼叫
    * SetPass 呼叫–場景中不同可見材質的數目
    * 畫面播放速率–遊戲視圖中每秒的畫面格數量 (可讓您大致瞭解發生的情況;幕後應該一律在應用程式內，使用 Oculus 幀的面板來測試，因為 fps 讀出永遠與編輯器中的內容不同) 

* 在 [視窗/分析]/[框架偵錯工具]) 下找到 **框架偵錯工具** (。  啟用時，類固醇上的 [統計資料] 面板可讓您查看 GPU 繪製的內容，以建立最終映射，顯示從 first 到 last 的 drawcalls 清單。  這會讓您瞭解為什麼繪製呼叫未以先前的繪製呼叫進行批次處理 (也就是「此物件使用不同的材質」或「這個物件使用不同的 Lightmap」 ) ，而且是一個絕佳的方式，可讓您瞭解您場景中的這兩種情況，以及如何以及為何某些視覺效果選擇可能會耗費大量計算資源。

* **Profiler** 會顯示當遊戲執行時，在任何時間點使用的電腦部分。 有助於判斷 bottlenecking 效能。  比方說，如果您在場景中看到大量的 CPU 使用率，這可能是因為有太多繪製呼叫，或如果您看到大量的 GPU 使用量， (也可能會發生太多的過度繪製，也就是轉譯單一圖元以產生最終影像) 的次數，可能是因為有多個透明的表面，或在超出視野時未挑選的物件。

## <a name="draw-calls-shadersmaterialsobjects"></a>**繪製呼叫 (著色器/材質/物件)**

* 每次需要轉譯著色器、材質或物件時，CPU 都必須指示交換器的 GPU (也稱為「繪製呼叫」，堆疊 **' drawcalls '**) 。  也就是說，如果您有5個著色器、10個材質和20個物件，則以最大者為准;您大約需要 20 drawcalls。  其他可乘以 drawcalls 的專案，包括在不同的 lightmaps 上具有物件，或在場景中有一個以上的即時光線 (也就是說，一個點光線會將另一個 drawcall 新增至其) 範圍內的每個物件，因此通常應該避免場景的方向光線以外的任何專案。  反映探查和淺色探查也會將繪製呼叫乘以它們所叫用的任何物件，因此應該避免它們。

* **靜態批次處理** 會在傳送至 GPU (時，將類似材質的物件批次處理成單一物件，) 並將上述範例中的所有物件都設定為 [靜態]，藉此將上述範例中的所有物件都設定為 [靜態]，就可以將場景縮減為大約 10 drawcalls，1代表每個材質。 

* 當物件具有與另一個物件完全相同的材質時，就會發生資料 **批次**; 不過，如果物件有多個資料，則不會使用具有較少材質的物件進行批次處理。  基於這個理由： **物件必須只有1個** 資料，而使用數個材質的物件應該分割成每個材質的個別物件。  您可以透過 **材質 Atlasing** 來縮減 **材質批次** (結合多個唯一物件的材質來共用單一材質表，讓它們全都使用相同的材質) 。  如果可能的話，請儘量將圖集數量維持在單一2k 或4k 材質/材質之間。

## <a name="scene-complexity"></a>**場景複雜性**

* **幾何** -嘗試為10萬以下的環境保持螢幕三角形。  使用 Unity 遊戲面板中的 [統計資料] 索引標籤，以查看您在場景中的各種有利點所達到的三角形計數。  這種情況的 .props 應該是在三角形範圍的 ' 數百 ' 中，而且只有在數以千計的三角形範圍中 .props 重要的「主圖」。 

* 在技術上，您可以使用 **LODs** (層級的詳細資料網格) ，雖然 Unity 的預設 lightmap 解決方案並不會在 LODs 之間共用 lightmap 資料，因此您可以在此解決方案的 lightmapping 切換時取得 LODs 構件。  或者，您也可以使用」 LOD 群組元件來進行簡單的距離剔除，即使物件沒有較低的」 LOD 網格也一樣：

![Unity 中的」 LOD 群組視窗](images/world-building-lod-Group.png)

* **遮蔽的剔除** 會減少轉譯成隻有相機視圖中的物件，而且會立即看見 (也就是說，從 view pixels occluded 的物件是挑選) 。  遮蔽的剔除應該幾乎一律針對您的場景進行內建，而層級應設計來支援它 (也就是，如果您有較大的層級，您可以使用牆或大型物件來分割播放程式的程式碼，如此一來，他們就不能一直看到到層級的相對端點。  預設的製作設定應該可以運作，不過您可能必須壓縮「最小 Occluder」或「最小洞」值。  針對您可以在物件或透明物件中看到的物件等物件，您應該在 [靜態] 下拉式功能表中關閉物件的「Occluder」狀態，使其背後的物件不會錯誤地 pixels occluded。 

## <a name="lightmaps"></a>**Lightmaps**

* 在理想情況下， **每個場景只會有一個 lightmap** (一個2k 或一個4k 用於所有) 的專案;較低的解析度 lightmaps 比許多較低的解析度 lightmaps 更好。
* 擁有多個 lightmaps 也會影響繪製呼叫的數目，因為有或沒有 lightmaps 的物件會在不同的批次，而其他 lightmaps 也會在不同的批次上。
* 一般來說， **每個單位大約25個材質** 的 Lightmap 解析度應已足夠 (設定 [光源/場景設定]) 中的解析度。  如果您的 lightmap 有額外的空間，您可以增加這個值。
* 變更每個物件的 **Lightmap 調整** 設定，以便為需要的物件儲存解析度。 

* **Lightmap 調整圖表** (thumb) 的規則 
    * **前景** (可周遊層級地理) ：1 
    * **.Props** (特別是 .props 小於人類) ： **2-3** (以避免物件上的 lightmap 成品和接縫)  
    * **Midground** 位於可周遊區域和/或大型物件（例如大樓) ： **0.5** ）之外的 (幾何
    * **背景** (Vista/遙遠的物件) ： **0.02** 
    * **透明表面** (例如玻璃) ： **0** (已停用 ' Cast/Receive Shadows ')  

此外，作為基準，以下是用於螢幕畫面門效果環境的一些設定：

![Unity 中的光源視窗](images/world-building-lightmaps.png)

## <a name="texture-compressionfile-size"></a>**紋理壓縮/檔案大小**

* 針對我們的 Android 組建，我們會嘗試將 Unity 套件場景大小保持在大約 10-20 MB 的總。  作法是透過在許多物件之間共用一般材質、使用頂點色彩來為物件加上色調，也可以設定 Android 的手動覆寫，讓紋理使用 **ASTC 6x6 block 壓縮**，這會比預設壓縮小。

* 我們未將 Android 組建設定設為 [使用 ASTC] 的原因是因為 lightmaps 不適合該壓縮 (許多 blocky 成品) ，而且我們必須在每個製作之後設定 lightmap 以使用等，如此一來，就可以更輕鬆地設定所有場景紋理的覆寫，而不是在每個 lightmap 之後更新製作的壓縮設定。

![Unity 中的材質視窗](images/world-building-texutres.png)

* 此外，將材質設定為使用具有2個非等層級的三線性篩選模式，可協助它們在 glancing 角度保持銳利。

您可以在「 [改善世界效能」檔](improving-performance.md)中找到更多的效能秘訣和訣竅。